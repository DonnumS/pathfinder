{"version":3,"sources":["assets/compass.png","PathfindingVisualizer/Node/Node.jsx","utils/NavBar.js","algorithms/dijkstra.js","utils/stack.js","algorithms/dfs.js","utils/q.js","algorithms/bfs.js","algorithms/a*.js","algorithms/greedybfs.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","algoOptions","key","text","value","NavBar","handleChange","e","setState","hideFixedMenu","fixed","showFixedMenu","state","chosenAlgo","onClearPathPressed","onClearAllPressed","Menu","inverted","style","backgroundColor","Container","Item","as","header","Image","size","src","require","marginRight","position","Dropdown","onChange","options","placeholder","selection","Button","marginLeft","color","onClick","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","Stack","items","element","isEmpty","pop","output","i","getNeighbors","width","height","directions","console","log","Queue","queue","offset","getLength","enqueue","item","dequeue","slice","peek","undefined","getAllFourNeighbors","visited","yetToVisit","astar","Heap","a","b","fCost","gCost","hCost","initializeCosts","heapify","currNode","unvisitedNeighbours","manhattanDistance","updateItem","euclideanDistance","colA","colB","rowA","rowB","Math","abs","aSquared","pow","bSquared","greedyBFS","PathfindingVisualizer","mouseIsPressed","finishIsPressed","startIsPressed","getInitialGrid","newGrid","getNewGridWithWallToggled","setTimeout","animateShortestPath","document","getElementById","removePath","animateVisited","stack","visitedNodes","parent","DFS","path","getShortestDFSPath","BFS","getShortestBFSPath","all","createNode","algoNum","visualizeDijkstra","visualizeDFS","visualizeBFS","visualizeAStar","visualizeGBFS","runAlgo","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ffebda3a.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/compass.c7899a90.png\";","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport {\n  Container,\n  Divider,\n  Dropdown,\n  Grid,\n  Header,\n  Image,\n  List,\n  Menu,\n  Button,\n  Segment,\n} from \"semantic-ui-react\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nconst algoOptions = [\n  {\n    key: \"Dijkstra\",\n    text: \"Dijkstra\",\n    value: \"1\",\n  },\n  {\n    key: \"DFS\",\n    text: \"DFS\",\n    value: \"2\",\n  },\n  {\n    key: \"BFS\",\n    text: \"BFS\",\n    value: \"3\",\n  },\n  {\n    key: \"AStar\",\n    text: \"A*\",\n    value: \"4\",\n  },\n  {\n    key: \"Greedy Best First Search\",\n    text: \"Greedy Best First Search\",\n    value: \"5\",\n  },\n];\n\nexport default class NavBar extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  handleChange = (e, { value }) => this.setState({ value });\n  hideFixedMenu = () => this.setState({ fixed: false });\n  showFixedMenu = () => this.setState({ fixed: true });\n\n  render() {\n    const { value } = this.state;\n    const { chosenAlgo, onClearPathPressed, onClearAllPressed } = this.props;\n\n    return (\n      <Menu fixed=\"top\" inverted style={{ backgroundColor: \"#061830\" }}>\n        <Container>\n          <Menu.Item as=\"a\" header>\n            <Image\n              size=\"mini\"\n              src={require(\"../assets/compass.png\")}\n              style={{ marginRight: \"1.5em\" }}\n            />\n            Pathfinding Visualizer\n          </Menu.Item>\n          <Menu.Item position=\"centre\">\n            <Dropdown\n              onChange={this.handleChange}\n              options={algoOptions}\n              placeholder=\"Select algorithm\"\n              selection\n              value={value}\n            />\n            <Button\n              style={{ marginLeft: 16 }}\n              color=\"green\"\n              onClick={() => chosenAlgo(value)}\n            >\n              Run\n            </Button>\n            <Button\n              style={{ marginLeft: 16 }}\n              color=\"orange\"\n              onClick={() => onClearAllPressed()}\n            >\n              Clear Everything\n            </Button>\n            <Button\n              style={{ marginLeft: 16 }}\n              color=\"orange\"\n              onClick={() => onClearPathPressed()}\n            >\n              Clear Path\n            </Button>\n          </Menu.Item>\n        </Container>\n      </Menu>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export class Stack {\n  constructor() {\n    this.items = [];\n  }\n  push(element) {\n    this.items.push(element);\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return \"Failed to pop because: Stack was empty.\";\n    } else {\n      return this.items.pop();\n    }\n  }\n  front() {\n    if (this.isEmpty()) {\n      return \"Failed to peek because: Stack was empty\";\n    } else {\n      return this.items[this.items.length - 1];\n    }\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  length() {\n    return this.items.length;\n  }\n  printStack() {\n    var output = \"\";\n    for (let i = 0; i < this.items.length; i++) {\n      output += this.items[i] + \" \";\n    }\n    return output;\n  }\n}\n","import { Stack } from \"../utils/stack.js\";\n\nexport function DFS(grid, startNode, finishNode, width, height) {\n  const stack = new Stack();\n  const visitedNodes = [];\n  stack.push(startNode);\n  console.log(\"Started\");\n  while (!stack.isEmpty()) {\n    let currentNode = stack.pop();\n    visitedNodes.push(currentNode);\n    currentNode.isVisited = true;\n    if (currentNode === finishNode) {\n      return getVisitedNodes(visitedNodes);\n    }\n\n    for (let neighbor of getNeighbors(grid, currentNode, width, height)) {\n      if (neighbor.isWall) {\n        continue;\n      }\n      if (!neighbor.isVisited) {\n        neighbor.parent = currentNode;\n        stack.push(neighbor);\n      }\n    }\n  }\n  return getVisitedNodes(visitedNodes);\n}\n\nfunction getVisitedNodes(visitedNodes) {\n  return visitedNodes;\n}\n\nfunction getNeighbors(grid, currentNode, width, height) {\n  const neighbors = [];\n  const row = currentNode.row;\n  const col = currentNode.col;\n  var directions = [2, 4, 3, 1];\n  for (let i = 0; i < directions.length; i++) {\n    switch (directions[i]) {\n      case 1:\n        if (row > 0) {\n          neighbors.push(grid[row - 1][col]);\n        }\n        break;\n      case 2:\n        if (col > 0) {\n          neighbors.push(grid[row][col - 1]);\n        }\n        break;\n      case 3:\n        if (col < width - 1) {\n          neighbors.push(grid[row][col + 1]);\n        }\n\n        break;\n      case 4:\n        if (row < height - 1) {\n          neighbors.push(grid[row + 1][col]);\n        }\n\n        break;\n      case 5:\n        if (row > 0 && col > 0) {\n          neighbors.push(grid[row - 1][col - 1]);\n        }\n        break;\n      case 6:\n        if (row > 0 && col < width - 1) {\n          neighbors.push(grid[row - 1][col + 1]);\n        }\n        break;\n      case 7:\n        if (row < height - 1 && col > 0) {\n          neighbors.push(grid[row + 1][col - 1]);\n        }\n        break;\n      case 8:\n        if (row < height - 1 && col < width - 1) {\n          neighbors.push(grid[row + 1][col + 1]);\n        }\n        break;\n      default:\n        console.log(\"Error choosing neighbor, value not in range [1,8].\");\n        break;\n    }\n  }\n  return neighbors;\n}\n\nexport function getShortestDFSPath(startNode, finishNode) {\n  const path = [];\n  let currentNode = finishNode;\n\n  while (currentNode.parent != null) {\n    path.unshift(currentNode);\n    currentNode = currentNode.parent;\n  }\n\n  path.unshift(startNode);\n\n  return path;\n}\n","export class Queue {\n  constructor() {\n    // initialise the queue and offset\n    var queue = [];\n    var offset = 0;\n    // Returns the length of the queue.\n    this.getLength = function () {\n      return queue.length - offset;\n    };\n    // Returns true if the queue is empty, and false otherwise.\n    this.isEmpty = function () {\n      return queue.length === 0;\n    };\n    /* Enqueues the specified item. The parameter is:\n     *\n     * item - the item to enqueue\n     */\n    this.enqueue = function (item) {\n      queue.push(item);\n    };\n    /* Dequeues an item and returns it. If the queue is empty, the value\n     * 'undefined' is returned.\n     */\n    this.dequeue = function () {\n      // if the queue is empty, return immediately\n      if (queue.length === 0) return undefined;\n      // store the item at the front of the queue\n      var item = queue[offset];\n      // increment the offset and remove the free space if necessary\n      if (++offset * 2 >= queue.length) {\n        queue = queue.slice(offset);\n        offset = 0;\n      }\n      // return the dequeued item\n      return item;\n    };\n    /* Returns the item at the front of the queue (without dequeuing it). If the\n     * queue is empty then undefined is returned.\n     */\n    this.peek = function () {\n      return queue.length > 0 ? queue[offset] : undefined;\n    };\n  }\n}\n","import { Queue } from \"../utils/q.js\";\n\nexport function BFS(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  const visitedNodesInOrder = [];\n  // Init q\n  var queue = new Queue();\n\n  // Set startNode dist = 0 and add to q\n  startNode.distance = 0;\n  queue.enqueue(startNode);\n\n  while (queue.length !== 0) {\n    var currentNode = queue.dequeue();\n\n    // checks for any invalid nodes\n    if (typeof currentNode === \"undefined\") return visitedNodesInOrder;\n\n    // Skip if node is a wall\n    if (currentNode.isWall) continue;\n\n    // Mark as visited and add to list of visited\n    currentNode.distance = 0;\n    currentNode.visited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    // Return when we hit finish\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    // Add unvisited neighbours to q\n    const unvisitedNeighbours = getUnvisitedNeighbors(currentNode, grid);\n    for (const neighbor of unvisitedNeighbours) {\n      if (!neighbor.isWall) {\n        queue.enqueue(neighbor);\n        neighbor.visited = true;\n        neighbor.previousNode = currentNode;\n        neighbor.distance = 0;\n      }\n    }\n  }\n}\n\n// Get neighbours\nexport function getAllFourNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors;\n}\n\n// Get unvisited neighbours of current node\nexport function getUnvisitedNeighbors(node, grid) {\n  var neighbors = getAllFourNeighbors(node, grid);\n\n  // Return neighbours that have not been visited\n  return neighbors.filter((neighbor) => !neighbor.visited);\n}\n\n// Get the shortest path from start to finish\nexport function getShortestBFSPath(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import { getUnvisitedNeighbors } from \"../algorithms/bfs\";\nimport Heap from \"heap\";\n\nvar yetToVisit;\n\nexport function astar(grid, startNode, finishNode) {\n  // checks for invalid inputs\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  const visitedNodesInOrder = [];\n\n  // create a priority queue where heap.pop() is the node with the lowest fCost\n  yetToVisit = new Heap(function (a, b) {\n    return a.fCost - b.fCost;\n  });\n\n  // make all nodes have fCost, gCost, hCost infinity at first\n  initializeCosts(grid);\n\n  // set the costs of the startNode to 0\n  startNode.fCost = 0;\n  startNode.gCost = 0;\n  startNode.hCost = 0;\n\n  // create a priority queue using a min-heap\n  yetToVisit.heapify();\n\n  while (yetToVisit.length !== 0) {\n    const currNode = yetToVisit.pop();\n\n    // if node is undefined or current node has fCost of infinity, returns the list of visited nodes\n    if (typeof currNode === \"undefined\" || currNode.fCost === Infinity)\n      return visitedNodesInOrder;\n\n    // if the node is a wall, continues running\n    if (currNode.isWall) continue;\n\n    // marks the node as visited and add it to the list of visited nodes\n    currNode.visited = true;\n    visitedNodesInOrder.push(currNode);\n\n    // if the node equals the finish node, returns the list of visited nodes\n    if (currNode === finishNode) return visitedNodesInOrder;\n\n    // for all unvisited neighbors of the node, calculate the heuristic h(n),\n    // Manhattan distance is used for calculating h(n). Then checks the condition of g(n) and\n    // updates the costs of the node respectively.\n    const unvisitedNeighbours = getUnvisitedNeighbors(currNode, grid);\n    for (const neighbor of unvisitedNeighbours) {\n      if (!neighbor.isWall) {\n        let hCost = manhattanDistance(\n          neighbor.col,\n          finishNode.col,\n          neighbor.row,\n          finishNode.row\n        );\n\n        if (currNode.gCost + 1 < neighbor.gCost) {\n          neighbor.hCost = hCost;\n          neighbor.gCost = currNode.gCost + 1;\n          neighbor.fCost = neighbor.hCost + neighbor.gCost;\n          neighbor.previousNode = currNode;\n          yetToVisit.updateItem(neighbor);\n        }\n      }\n    }\n  }\n  return visitedNodesInOrder;\n}\n\n// calculates the Euclidean distance\nexport function euclideanDistance(colA, colB, rowA, rowB) {\n  const a = Math.abs(colA - colB);\n  const b = Math.abs(rowA - rowB);\n  const aSquared = Math.pow(a, 2);\n  const bSquared = Math.pow(b, 2);\n  return Math.pow(aSquared + bSquared, 0.5);\n}\n\n// calculates the Manhanttan distance\nexport function manhattanDistance(colA, colB, rowA, rowB) {\n  const a = Math.abs(colA - colB);\n  const b = Math.abs(rowA - rowB);\n  return a + b;\n}\n\n// Make all nodes' fCost, gCost and hCost values initialized to infinity\n// and stores it in the heap.\nfunction initializeCosts(grid) {\n  for (let row of grid) {\n    for (let node of row) {\n      node.fCost = Infinity;\n      node.gCost = Infinity;\n      node.hCost = Infinity;\n      yetToVisit.push(node);\n    }\n  }\n}\n","import Heap from \"heap\";\nimport { getUnvisitedNeighbors } from \"../algorithms/bfs\";\nimport { euclideanDistance } from \"../algorithms/a*\";\n\nvar yetToVisit;\n\nexport function greedyBFS(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  const visitedNodesInOrder = [];\n\n  yetToVisit = new Heap(function (a, b) {\n    return a.fCost - b.fCost;\n  });\n\n  // Init costs\n  initializeCosts(grid);\n\n  startNode.fCost = 0;\n  yetToVisit.updateItem(startNode);\n  yetToVisit.heapify();\n\n  while (yetToVisit.size() > 0) {\n    // Get node with lowest f cost\n    const currentNode = yetToVisit.pop();\n\n    // Check if invalid\n    if (typeof currentNode === \"undefined\") return visitedNodesInOrder;\n\n    // If fcost is inf, return the visited list\n    if (currentNode.fCost === Infinity) return visitedNodesInOrder;\n\n    // Skip walls\n    if (currentNode.isWall) continue;\n\n    // Mark as visited and push\n    currentNode.visited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    // Return if we are at finish\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    // Calculate heuristic for all unvisited neighbours\n    const unvisitedNeighbours = getUnvisitedNeighbors(currentNode, grid);\n    for (const neighbor of unvisitedNeighbours) {\n      if (!neighbor.isWall) {\n        const hCost = euclideanDistance(\n          neighbor.col,\n          finishNode.col,\n          neighbor.row,\n          finishNode.row\n        );\n\n        if (neighbor.fCost > hCost) {\n          neighbor.fCost = hCost; //no g cost\n          neighbor.previousNode = currentNode;\n          yetToVisit.updateItem(neighbor);\n        }\n      }\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\n// Init h and f costs\nfunction initializeCosts(grid) {\n  for (let row of grid) {\n    for (let node of row) {\n      node.fCost = Infinity;\n      node.hCost = Infinity;\n      yetToVisit.push(node);\n    }\n  }\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport NavBar from \"../utils/NavBar\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\nimport { DFS, getShortestDFSPath } from \"../algorithms/dfs\";\nimport { BFS, getShortestBFSPath } from \"../algorithms/bfs\";\nimport { astar } from \"../algorithms/a*\";\nimport { greedyBFS } from \"../algorithms/greedybfs\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 5;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 40;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      finishIsPressed: false,\n      startIsPressed: false,\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  // Animates the order in which all visited nodes where visited\n  animateVisited(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n\n  // Animates the shortest path\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  }\n\n  // Used to visualize dijkstra, simple version\n  visualizeDijkstra() {\n    this.removePath(false);\n    console.log(\"1 = Dijkstra\");\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisited(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  // Used to visualize DFS\n  visualizeDFS() {\n    this.removePath(false);\n    console.log(\"2 = DFS\");\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = DFS(grid, startNode, finishNode, 50, 20);\n    const nodesInShortestPathOrder = getShortestDFSPath(startNode, finishNode);\n    this.animateVisited(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  // Used to visualize BFS\n  visualizeBFS() {\n    this.removePath(false);\n    console.log(\"3 = BFS\");\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = BFS(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getShortestBFSPath(finishNode);\n    this.animateVisited(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  // Used to visualize A*\n  visualizeAStar() {\n    this.removePath(false);\n    console.log(\"4 = A*\");\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = astar(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisited(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeGBFS() {\n    this.removePath(false);\n    console.log(\"4 = A*\");\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisited(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  // Clears path, but currently also clears node start and finish from the board\n  clearPath() {\n    this.setState({ grid: [] });\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  // Used to remove path or remove path and all walls\n  removePath(all) {\n    const { grid } = this.state;\n    for (let row = 0; row < 20; row++) {\n      for (let col = 0; col < 50; col++) {\n        const node = grid[row][col];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node\";\n        if (row === START_NODE_ROW && col === START_NODE_COL) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-start\";\n        } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n          grid[row][col] = createNode(col, row);\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-finish\";\n        } else if (grid[row][col].isWall && !all) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-wall\";\n        } else {\n          grid[row][col] = createNode(col, row);\n        }\n      }\n    }\n  }\n\n  // Run desired algorithm given value from dropdown menu\n  runAlgo(algoNum) {\n    console.log(`Run algo ${algoNum}`);\n    if (algoNum == 1) {\n      this.visualizeDijkstra();\n    } else if (algoNum == 2) {\n      this.visualizeDFS();\n    } else if (algoNum == 3) {\n      this.visualizeBFS();\n    } else if (algoNum == 4) {\n      this.visualizeAStar();\n    } else if (algoNum == 5) {\n      this.visualizeGBFS();\n    }\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <div>\n        <NavBar\n          chosenAlgo={(value) => this.runAlgo(value)}\n          onClearPathPressed={() => this.removePath(false)}\n          onClearAllPressed={() => this.removePath(true)}\n        />\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}